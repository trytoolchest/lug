{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lug","text":"<p>If you're ready to start building, head straight to Installation or  Adding Lug to a Function.</p>"},{"location":"#what-does-lug-do","title":"What does Lug do?","text":"<p>Lug is a tool that allows you to move the execution of specific Python functions to different environments on each call.  This means that instead of deploying a function permanently to a specific environment (e.g. your local computer or a  cloud-based server), you can choose where you want to run the function at the time of execution. This flexibility  allows you to optimize your resource consumption and cost for the needs of the specific function.</p> <p>Lug is particularly useful for computational science, where researchers and scientists often have programs that are  challenging to install and run. Lug automatically detects and packages pip-installed dependencies and local modules,  and you can even attach a sidecar Docker image for the command-line programs that need their own image \u2013 making it  simple to debug and scale your code.</p>"},{"location":"#what-isnt-lug-good-at-yet","title":"What isn't Lug good at (yet)?","text":"<ul> <li>Short-running functions \u2013 there's a startup time (1-5 minutes) for each cloud run</li> <li>Hosting for reference databases / models / etc (try Toolchest for that if you're in bio)</li> <li>TensorFlow</li> </ul>"},{"location":"#why-lug","title":"Why Lug?","text":"<ul> <li>It's one line of code</li> <li>You don't need to statically define your dependencies</li> <li>Lug is open source (Apache 2.0)</li> </ul>"},{"location":"getting-started/create-a-hybrid-function/","title":"Create a Hybrid Function","text":"<p>With Lug, you can easily create hybrid functions that can run both locally and in the cloud. First, let's create a  simple Python function that tells us how many CPUs our system has. We'll use the <code>multiprocessing</code> library to do this:</p> <pre><code>import multiprocessing\n\ndef num_cpus():\n    return multiprocessing.cpu_count()\n\nprint(num_cpus())\n</code></pre> <p>This function will print the number of CPUs on the system. On my laptop, that number is \"10\".</p> <p>Now, let's make this function a \"hybrid function\" using Lug. To do this, we'll import the Lug library and add the  <code>@lug.hybrid()</code> decorator to the function: <pre><code>import lug\nimport multiprocessing\n\n@lug.hybrid(cloud=False)\ndef num_cpus():\n    return multiprocessing.cpu_count()\n\nprint(num_cpus())\n</code></pre></p> <p>This will give us the same output as before, since we are still running the function on our local system. However, by  using the <code>@lug.hybrid()</code> decorator, we have now made our function \"hybrid\" and it can easily move it to the cloud if  we wish to do so in the future.</p>"},{"location":"getting-started/docker-sidecar/","title":"Create a Docker Sidecar Function","text":"<p>Lug Docker Sidecar functions are like regular Lug Hybrid functions, but with an added bonus: they run a Docker  container alongside your function. This is helpful for programs that work best in their own separate container and that  you execute via shell.</p>"},{"location":"getting-started/docker-sidecar/#running-locally","title":"Running locally","text":"<p>To create a Docker Sidecar function, use the <code>@lug.docker_sidecar</code> decorator and specify the Docker image you want to  use with the <code>sidecar_image</code> argument. Then, you can use the <code>lug.sidecar_shell</code> function to run shell commands inside  the container.</p> <p>Here's an example that shows how to use a bioinformatics package in a sidecar container:</p> <pre><code>import lug\n\n@lug.docker_sidecar(sidecar_image='biocontainers/bowtie2:v2.4.1_cv1')\ndef run_bowtie2():\n    result = lug.sidecar_shell(\"bowtie2 --version \")\n    return result.stdout\n\nprint(run_bowtie2())\n</code></pre> <p><code>lug.sidecar_shell()</code> is similar to the Python <code>subprocess.run</code> function, so you can expect similar return values and  attributes \u2013 like <code>result.stdout</code> in the example above. You can also pass the same arguments to <code>lug.sidecar_shell</code>  that you would to <code>subprocess.run</code>.</p>"},{"location":"getting-started/docker-sidecar/#running-in-the-cloud","title":"Running in the cloud","text":"<p>Running a Docker Sidecar function in the cloud is exactly the same as running a Hybrid function in the cloud: you just  need to add the <code>cloud=True</code> argument and set your Toolchest key:</p> <pre><code>import lug\n\n@lug.docker_sidecar(\n    sidecar_image='biocontainers/bowtie2:v2.4.1_cv1',\n    cloud=True,\n    key=\"YOUR_KEY_HERE\"\n)\ndef run_bowtie2():\n    result = lug.sidecar_shell(\"bowtie2 --version \")\n    return result.stdout\n\nprint(run_bowtie2())\n</code></pre> <p>You can also grant more power to your function or use a different cloud provider,  following the same steps as with Hybrid functions.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Note: if you're using Lug with Docker containers, make sure you  install and start Docker Engine!</p>"},{"location":"getting-started/installation/#with-pip","title":"With <code>pip</code>","text":"<pre><code>pip install lug\n</code></pre>"},{"location":"getting-started/installation/#with-poetry","title":"With Poetry","text":"<pre><code>poetry add lug\n</code></pre>"},{"location":"getting-started/installation/#supported-python-versions","title":"Supported Python versions","text":"<p>Lug supports Python 3.8 through the latest Python 3.12 release candidate.</p>"},{"location":"getting-started/installation/#supported-operating-systems","title":"Supported operating systems","text":"<p>You can run Lug locally on most recent versions of macOS, Linux and Windows. To run Lug remotely,  you'll need macOS or Linux (tested on CentOS, Debian, Ubuntu, and Amazon Linux 2).</p>"},{"location":"getting-started/running-lug-remotely/","title":"Running Hybrid Functions in the Cloud","text":""},{"location":"getting-started/running-lug-remotely/#get-an-api-key","title":"Get an API key","text":"<p>To run a function in the cloud using Lug, you will need to get an API key from Toolchest. Here's how:</p> <ol> <li>First, sign up for a free Toolchest account.</li> <li>Log in and navigate to the API Keys section.</li> <li>Click on \"Generate New Key\" to create a new API key.</li> <li>Once you have the key, you can use the Toolchest app to monitor your runs, execute in the cloud, or connect your own  on-prem servers.</li> </ol> <p>Note: Lug uses Toolchest for cloud execution, so an API key from Toolchest is required to use Lug's cloud functionality.</p>"},{"location":"getting-started/running-lug-remotely/#run-your-hybrid-function-in-the-cloud","title":"Run your hybrid function in the cloud","text":"<p>To run your hybrid function on the cloud, set the <code>cloud</code> parameter to <code>True</code>. You'll also need to set your Toolchest  API key in the <code>key</code> parameter.</p> <p>Here's an example of how to use the <code>@lug.hybrid</code> decorator to run a <code>num_cpus</code> function on the cloud:</p> <pre><code>import lug\nimport multiprocessing\n\n@lug.hybrid(cloud=True, key=\"YOUR_KEY_HERE\")\ndef num_cpus():\n    return multiprocessing.cpu_count()\n\nprint(num_cpus())\n</code></pre> <p>This will run the <code>num_cpus</code> function on the cloud using the smallest available instance (2 CPUs) by default. Once the  execution is finished, you will see the number of CPUs returned as the result. By default, Lug uses AWS as the cloud  provider.</p>"},{"location":"getting-started/running-lug-remotely/#adding-more-power","title":"Adding more power","text":"<p>If you want to give the function more resources, you can specify a different instance type when you decorate the  function. For example, if you want to grant 48 CPUs, you can set the instance type to \"compute-48\":</p> <pre><code>import lug\nimport multiprocessing\n\n@lug.hybrid(cloud=True, key=\"YOUR_KEY_HERE\", instance_type=\"compute-48\")\ndef num_cpus():\n    return multiprocessing.cpu_count()\n\nprint(num_cpus())\n</code></pre> <p>This will run the function on an instance with 48 CPUs. You can use any of the cloud-generic  available Toolchest instance types by replacing  \"compute-48\" with the desired instance type.</p>"},{"location":"getting-started/running-lug-remotely/#running-on-another-cloud","title":"Running on another cloud","text":"<p>You can also run your function on another cloud provider \u2013 or your on-prem servers \u2013 as long as it's connected to your  Toolchest account. By default, every account has access to the lower-cost queued Toolchest Cloud Extension (TCE), so  we'll use it for this example.</p> <p>To run your Lug functions in TCE, simply set the <code>provider</code> argument to \"tce\" in the <code>@lug.hybrid</code> function call.</p> <pre><code>import lug\nimport multiprocessing\n\n@lug.hybrid(\n    cloud=True,\n    key=\"YOUR_KEY_HERE\",\n    instance_type=\"compute-48\",\n    provider=\"tce\", # add this line\n)\ndef num_cpus():\n    return multiprocessing.cpu_count()\n\nprint(num_cpus())\n</code></pre> <p>This allows for easy switching between different environments and providers, making it easy to scale your computation  while utilizing specialized or lower-cost infrastructure.</p>"},{"location":"getting-started/running-lug-remotely/#theres-more","title":"There's more!","text":"<p>This covers the basic of running Lug functions, but you can do a lot more than just print the number of CPUs! Check out  some of our Lug examples.</p>"},{"location":"getting-started/using-files/","title":"Using files","text":""},{"location":"getting-started/using-files/#accessing-files-locally","title":"Accessing files locally","text":"<p>When running a function with Lug locally, the Python function's file access doesn't change. If you aren't using  Docker Sidecar, you can skip this section!</p> <p>If you are running a Docker Sidecar function locally, the access to your system's file system is a bit different. The  files in your system can be accessed inside the Docker container through the <code>/lug</code> directory. You can change the root  directory that's attached to the container with the <code>mount</code> parameter.</p> <p>Here's an example that accesses the root directory of the host file system from inside the Docker container:</p> <pre><code>import lug\n\n@lug.docker_sidecar(image=\"alpine:3.16.2\", mount=\"/\")\ndef list_root():\n    result = lug.sidecar_shell(\"ls /lug/\")\n    return result.stdout\n\nprint(list_root())\n</code></pre> <p>In this example, the function <code>list_root</code> uses the <code>lug.sidecar_shell</code> function to execute the <code>ls</code> command inside the  Docker container and returns the output. The <code>mount</code> parameter is set to <code>/</code>, so the root directory of the host's file  system is mounted at <code>/lug</code> inside the Docker container.</p> <p>Lug's <code>mount</code> is a Docker mount point</p> <p>Lug's <code>mount</code> is a Docker mount point. This means that Docker must have permission to access the mount point. Some  environments, like Docker Desktop on macOS, require explicitly adding permissions for non-user files \u2013 even if  you're running as <code>root</code>.</p>"},{"location":"getting-started/using-files/#accessing-files-with-absolute-paths","title":"Accessing files with absolute paths","text":"<p>When using absolute paths in Lug, there are two things to keep in mind:</p> <ol> <li>Add a <code>/lug</code> prefix to the absolute path inside the Docker container</li> <li>The mount point set in the Docker sidecar should contain the path being referenced</li> </ol> <p>Here's an example that accesses a file created on the host system from within the Docker container using an absolute  path:</p> <pre><code>import lug\nimport os\n\ndef create_file(absolute_path):\n    with open(absolute_path, 'w') as f:\n        f.write('Hello, world!')\n\n@lug.docker_sidecar(sidecar_image=\"alpine:3.16.2\", mount=\"/\")\ndef cat_file(absolute_path):\n    result = lug.sidecar_shell(f\"cat /lug{absolute_path}\")\n    return result.stdout\n\nabsolute_path = os.path.abspath(\"test.txt\")\ncreate_file(absolute_path)\nprint(cat_file(absolute_path))\n</code></pre> <p>It will print <code>Hello, world!</code> if everything is set up correctly.</p>"},{"location":"getting-started/using-files/#accessing-files-in-cloud-runs","title":"Accessing files in cloud runs","text":"<p>To access files in remote runs, you need to set up input and output file handling.</p>"},{"location":"getting-started/using-files/#input-files","title":"Input files","text":"<p>You can pass input files to a Lug function by using the <code>remote_inputs</code> argument. The input files are accessible at  <code>./input/</code> on the remote instance.</p>"},{"location":"getting-started/using-files/#output-files","title":"Output files","text":"<p>To access output files, you need to specify a directory for the output files using the <code>remote_output_directory</code>  argument. The output files need to be written to <code>./output</code> on the remote instance.</p> <p>Both <code>remote_intputs</code> and <code>remote_output_directory</code> can be local paths or S3 URIs.</p>"},{"location":"getting-started/using-files/#example-usage","title":"Example usage","text":"<p>Here's an example that shows how to use remote files with a Lug Docker Sidecar:</p> <pre><code>import lug\nimport os\n\n@lug.docker_sidecar(\n    sidecar_image=\"alpine:3.16.2\",\n    remote_inputs=[\"./my_input/\"],\n    remote_output_directory=\"./my_output/\",\n    cloud=True,\n    key=\"YOUR_KEY_HERE\",\n)\ndef hello_world():\n    result = lug.sidecar_shell(\"cat ./input/one.txt &gt; ./output/two.txt\")\n    return result.stdout\n\nos.makedirs(\"./my_input\", exist_ok=True)\nfile_path = \"./my_input/one.txt\"\nwith open(file_path, 'w') as f:\n    f.write('Hello, world!')\n\nhello_world()\n</code></pre> <p>The <code>./my_output/</code> now has a file named <code>two.txt</code> with the contents \"Hello, world!\"</p>"},{"location":"troubleshooting/common-errors/","title":"Common errors","text":""},{"location":"troubleshooting/common-errors/#docker-isnt-installed-or-running","title":"Docker isn't installed or running","text":""},{"location":"troubleshooting/common-errors/#what-it-looks-like","title":"What it looks like:","text":"<pre><code>docker.errors.DockerException: Error while fetching server API version: ('Connection aborted.', FileNotFoundError(2, 'No such file or directory'))\n</code></pre>"},{"location":"troubleshooting/common-errors/#how-to-solve-it","title":"How to solve it:","text":"<p>Install and start Docker Engine: https://docs.docker.com/engine/install/</p>"},{"location":"troubleshooting/common-errors/#subprocessrun-cant-find-your-command","title":"<code>subprocess.run</code> can't find your command","text":""},{"location":"troubleshooting/common-errors/#what-it-looks-like_1","title":"What it looks like:","text":"<pre><code>FileNotFoundError: [Errno 2] No such file or directory: 'docker exec lug-c8eef2d5-adcd-4263-bf67-061b7ea56f68 /bin/sh -c \\'echo \"Hello, `uname`!\"\\''\n</code></pre> <pre><code>(no output, when you're expecting output)\n</code></pre>"},{"location":"troubleshooting/common-errors/#how-to-solve-it_1","title":"How to solve it:","text":"<ul> <li>If you're using <code>subprocess.run</code>, try setting using the <code>shell=True</code> argument. This sets a shell location and accepts  string commands as input, just like a terminal.  </li> <li>Make sure that the command exists in the Docker image, and if it's not in the <code>$PATH</code> use an absolute reference path.</li> </ul>"},{"location":"troubleshooting/common-errors/#it-runs-slowly","title":"It runs slowly","text":""},{"location":"troubleshooting/common-errors/#what-it-looks-like_2","title":"What it looks like:","text":"<p>The command runs slower than expected (e.g. 2x longer than before), after factoring in Docker container start time.</p>"},{"location":"troubleshooting/common-errors/#how-to-solve-it_2","title":"How to solve it:","text":"<p>Docker runs Linux containers in a VM on non-Linux machines. If you're using macOS, for example, Lug will run slower  than if you're on Linux.</p> <p>You can get more speed by running remotely with <code>remote=True</code> \u2013 under the hood, this uses a Linux machine.</p> <p>Without running remotely, this can't be solved without changing operating systems. If a Docker replacement comes along  that executes across different architectures with no VM, this could be solved!</p>"}]}